from pathlib import Path
from typing import Any, Dict, List, Optional, Union, Iterator, Callable

from haystack import Document, component, logging
from haystack.components.converters.utils import get_bytestream_from_source, normalize_metadata
from haystack.lazy_imports import LazyImport

import json

with LazyImport("Run 'pip install jq' Github - https://github.com/jqlang/jq ") as jq_import:
    import jq

logger = logging.getLogger(__name__)


@component
class JQToJSON:
    '''
        :param source:Single file path as string or Path object to JSON source
        :param jq_data_schema: jq query to operate on JSON source
        :param metadata_func: Optional function that takes in the JSON 
        object extracted by the jq_schema and returns
        a dict of metadata.  The metadata can be attached to each document
        that is generated by the JSON source
        :param metadata:Optional metadata common to all the Documents.
        This value is a dictionary that is added to all the documents 
        generated by a JSON source.
        :returns: Dictionary {"documents": List of documents that are the result of jq query applied 
        to the JSON source}

        """
        
    Example :
    
        file_path = Path('sample.json')
        jq_data_schema = '.prizes[].laureates[]?'
        output_dict =  json_to_doc.run(sources=file_path, jq_data_schema=jq_data_schema,
        metadata_func=metadata_func, metadata = {'dataset': 'nobel data set'},json_lines = json_lines)
        documents = output["documents"]
        
    '''
    
    def __init__(self: "JQToJSON") -> None:
        """
        Check to see if jq is installed
        """
        jq_import.check()
    
    @component.output_types(documents=List[Document])
    def run(
        self,
        sources: Union [str,Path],
        jq_data_schema: str,
        metadata_func: Optional[Callable[[Dict], Dict]] = None, 
        metadata: Optional[Dict[str, Any]] = {},   
        json_lines: bool = False
    ) -> List[Document]: # Output will be list of Docs each of which will contain JSON objects
        
        self._file_path = Path(sources).resolve()
        self._jq_data_schema = jq_data_schema
        self._metadata_func = metadata_func
        self._metadata = metadata
        self._json_lines = json_lines
        
    
        if self._json_lines:
            try:
                with self._file_path.open(encoding="utf-8") as f:
                    line_docs = []
                    for line in f:
                        line = line.strip()
                        if line:
                            docs = []
                            try:
                                for doc in self._single_doc(line):
                                    docs.append(doc)
                                line_docs.append(docs)
                            except Exception as e:
                                logger.error(f"Error processing line: {line}")
                                logger.error(f"Exception: {e}")
                    return {"documents": line_docs}
            except FileNotFoundError:
                logger.error(f"Error: The file {self._file_path} was not found.")
            except Exception as e:
                logger.error(f"An unexpected error occurred while reading the file {self._file_path}: {e}")

                return {"documents": line_docs}
        else:
            docs = []
            try:
                for doc in self._single_doc(self._file_path.read_text(encoding="utf-8")):
                    docs.append(doc)
            except FileNotFoundError:
                logger.error(f"Error: The file {self._file_path} was not found.")
            except Exception as e:
                logger.error(f"An unexpected error occurred while reading the file {self._file_path}: {e}")
            return {"documents": docs}

    
    def _single_doc(self, json_string: str) -> Iterator[Document]:
        doc_metadata = {}
        try:    
            jq_data_compiled_schema = jq.compile(self._jq_data_schema)
            data = jq_data_compiled_schema.input(json.loads(json_string)).all()
        except json.JSONDecodeError as e:
            logger.error(f"JSON decoding error: {e}")
            return 
        try:
            calculated_metadata = {}
            for i, sample in enumerate(data):
                if self._metadata_func is not None:
                    try:
                        calculated_metadata = self._metadata_func(sample)
                    except Exception as e:
                        #logger.error (f"sample: {sample}")
                        logger.error(f"metadata calculation error and sample : {e}")
                # seq number of docs starts at 1. Represents number of docs for a particular data set
                doc_metadata = {**self._metadata, **calculated_metadata}
                doc_metadata['seq_no'] = i + 1
                doc_metadata['file_path'] = str(self._file_path.name)
                doc_metadata ['jq_schema'] = self._jq_data_schema
                
                 # Check if the results are JSON-compatible
                if isinstance(sample, (dict, list, str, int, float, bool, type(None))):
                    content = json.dumps(sample)
                else:
                    content = str(sample)
                yield Document(content=content, meta=doc_metadata)
        except Exception as e:
            logger.error(f"Error processing JSON data: {json.dumps(json_string)}")
            logger.error(f"Exception: {e}")
